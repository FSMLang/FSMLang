/**
	subMachine2.c

	This file automatically generated by FSMLang
*/

#include "subMachine2_priv.h"
#include <stddef.h>

#ifndef DBG_PRINTF
#define DBG_PRINTF(...)
#endif

static NEW_MACHINE_EVENT sss1_stateFn(pSUB_MACHINE2,NEW_MACHINE_EVENT);
static NEW_MACHINE_EVENT sss2_stateFn(pSUB_MACHINE2,NEW_MACHINE_EVENT);
static NEW_MACHINE_EVENT sss3_stateFn(pSUB_MACHINE2,NEW_MACHINE_EVENT);

static const SUB_MACHINE2_STATE_FN subMachine2_state_fn_array[subMachine2_numStates] = 
{
	  sss1_stateFn
	, sss2_stateFn
	, sss3_stateFn
};

/* FSMLANG_DEVELOP: defineSubMachineIF */
NEW_MACHINE_EVENT newMachine_subMachine2_sub_machine_fn(NEW_MACHINE_EVENT e)
{
	return subMachine2FSM(psubMachine2,e);
}

NEW_MACHINE_SUB_FSM_IF newMachine_subMachine2_sub_fsm_if =
{
		.subFSM = newMachine_subMachine2_sub_machine_fn
	, .first_event = newMachine_subMachine2_eee1
	, .last_event = newMachine_subMachine2_eee3
};

/* FSMLANG_DEVELOP: defineSubMachineArray */
/* FSMLANG_DEVELOP: generateInstance */
SUB_MACHINE2 subMachine2 = {
	subMachine2_sss1,
	THIS(eee1),
	&subMachine2_state_fn_array,
	subMachine2FSM
};

pSUB_MACHINE2 psubMachine2 = &subMachine2;

/* FSMLANG_DEVELOP: defineCSwitchSubMachineFSM */

#ifndef EVENT_IS_NOT_EXCLUDED_FROM_LOG
#define EVENT_IS_NOT_EXCLUDED_FROM_LOG(e) (e == e)
#endif
NEW_MACHINE_EVENT subMachine2FSM(pSUB_MACHINE2 pfsm, NEW_MACHINE_EVENT event)
{
	NEW_MACHINE_EVENT e = event;

	while (
		(e != THIS(noEvent))
		&& (e >= THIS(eee1))
	)
	{

#ifdef SUB_MACHINE2_DEBUG
if (EVENT_IS_NOT_EXCLUDED_FROM_LOG(e))
{
	DBG_PRINTF("event: %s; state: %s"
,SUB_MACHINE2_EVENT_NAMES[e - THIS(eee1)]
,SUB_MACHINE2_STATE_NAMES[pfsm->state]
);
}
#endif

	/* This is read-only data to facilitate error reporting in action functions */
	pfsm->event = e;

		e = ((* (*pfsm->statesArray)[pfsm->state])(pfsm,e));

	}

	return e == THIS(noEvent) ? PARENT(noEvent) : e;
}

/* FSMLANG_DEVELOP: defineStateEntryAndExitManagers */
static NEW_MACHINE_EVENT sss1_stateFn(pSUB_MACHINE2 pfsm,NEW_MACHINE_EVENT e)
{
	NEW_MACHINE_EVENT retVal = THIS(noEvent);

	switch(e)
	{
	case THIS(eee1):
		retVal = newMachine_subMachine2_aaa1(pfsm);
		pfsm->state = subMachine2_sss2;
		break;
	case THIS(eee2):
		retVal = newMachine_subMachine2_aaa2(pfsm);
		pfsm->state = subMachine2_sss3;
		break;
	default:
		DBG_PRINTF("newMachine_subMachine2_noAction");
		break;
	}

	return retVal;
}

static NEW_MACHINE_EVENT sss2_stateFn(pSUB_MACHINE2 pfsm,NEW_MACHINE_EVENT e)
{
	NEW_MACHINE_EVENT retVal = THIS(noEvent);

	switch(e)
	{
	default:
		DBG_PRINTF("newMachine_subMachine2_noAction");
		break;
	}

	/* we only just now know we did not use this */
	(void) pfsm;

	return retVal;
}

static NEW_MACHINE_EVENT sss3_stateFn(pSUB_MACHINE2 pfsm,NEW_MACHINE_EVENT e)
{
	NEW_MACHINE_EVENT retVal = THIS(noEvent);

	switch(e)
	{
	default:
		DBG_PRINTF("newMachine_subMachine2_noAction");
		break;
	}

	/* we only just now know we did not use this */
	(void) pfsm;

	return retVal;
}


/* FSMLANG_DEVELOP: define_weak_action_function */
NEW_MACHINE_EVENT __attribute__((weak)) THIS(aaa1)(FSM_TYPE_PTR pfsm)
{
	DBG_PRINTF("weak: %s", __func__);
	(void) pfsm;
	return THIS(noEvent);
}

/* FSMLANG_DEVELOP: define_weak_action_function */
NEW_MACHINE_EVENT __attribute__((weak)) THIS(aaa2)(FSM_TYPE_PTR pfsm)
{
	DBG_PRINTF("weak: %s", __func__);
	(void) pfsm;
	return THIS(noEvent);
}


#ifdef SUB_MACHINE2_DEBUG
char *SUB_MACHINE2_EVENT_NAMES[] = {
	 "newMachine_subMachine2_eee1"
	,"newMachine_subMachine2_eee2"
	,"newMachine_subMachine2_eee3"
	, "subMachine2_noEvent"
	, "subMachine2_numEvents"
};

char *SUB_MACHINE2_STATE_NAMES[subMachine2_numStates] = {
	 "newMachine_subMachine2_sss1"
	,"newMachine_subMachine2_sss2"
	,"newMachine_subMachine2_sss3"
};

#endif
